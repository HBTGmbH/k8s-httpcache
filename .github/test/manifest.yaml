apiVersion: v1
kind: Namespace
metadata:
  name: test-ns
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend-xns
  namespace: test-ns
spec:
  replicas: 1
  selector:
    matchLabels:
      app: backend-xns
  template:
    metadata:
      labels:
        app: backend-xns
    spec:
      containers:
      - name: backend
        image: hashicorp/http-echo
        args: ["-listen=:8080", "-text=ok-xns"]
        ports:
        - name: http
          containerPort: 8080
          protocol: TCP
---
apiVersion: v1
kind: Service
metadata:
  name: backend-xns
  namespace: test-ns
spec:
  selector:
    app: backend-xns
  ports:
  - name: http
    protocol: TCP
    port: 80
    targetPort: http
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: k8s-httpcache
  namespace: test-ns
rules:
- apiGroups: [""]
  resources: ["services"]
  verbs: ["list", "watch"]
- apiGroups: ["discovery.k8s.io"]
  resources: ["endpointslices"]
  verbs: ["list", "watch"]
- apiGroups: [""]
  resources: ["configmaps"]
  verbs: ["list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: k8s-httpcache
  namespace: test-ns
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: k8s-httpcache
subjects:
- kind: ServiceAccount
  name: k8s-httpcache
  namespace: default
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
  namespace: default
spec:
  replicas: 1
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        image: hashicorp/http-echo
        args: ["-listen=:8080", "-text=ok"]
        ports:
        - name: http
          containerPort: 8080
          protocol: TCP
---
apiVersion: v1
kind: Service
metadata:
  name: backend
  namespace: default
spec:
  selector:
    app: backend
  ports:
  - name: http
    protocol: TCP
    port: 80
    targetPort: http
---
apiVersion: v1
kind: Service
metadata:
  name: backend-external
  namespace: default
spec:
  type: ExternalName
  externalName: backend.default.svc.cluster.local
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: k8s-httpcache
  namespace: default
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: k8s-httpcache
  namespace: default
rules:
- apiGroups: [""]
  resources: ["services"]
  verbs: ["list", "watch"]
- apiGroups: ["discovery.k8s.io"]
  resources: ["endpointslices"]
  verbs: ["list", "watch"]
- apiGroups: [""]
  resources: ["configmaps"]
  verbs: ["list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: k8s-httpcache
  namespace: default
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: k8s-httpcache
subjects:
- kind: ServiceAccount
  name: k8s-httpcache
  namespace: default
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: k8s-httpcache-values-test
  namespace: default
data:
  greeting: hello-from-values
  server: |
    host: example.com
    port: 8080
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: k8s-httpcache-values-dir-test
  namespace: default
data:
  greeting.yaml: hello-from-dir
  server.yaml: |
    host: dir.example.com
    port: 9090
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: k8s-httpcache
  namespace: default
spec:
  replicas: 3
  selector:
    matchLabels:
      app: k8s-httpcache
  template:
    metadata:
      labels:
        app: k8s-httpcache
    spec:
      serviceAccountName: k8s-httpcache
      terminationGracePeriodSeconds: 90
      containers:
      - name: k8s-httpcache
        image: k8s-httpcache:test
        imagePullPolicy: Never
        securityContext:
          allowPrivilegeEscalation: false
          privileged: false
          runAsUser: 1000  # <-- varnish user uses uid=1000 also in the container image
          runAsGroup: 1000  # <-- varnish user uses gid=1000 also in the container image
          runAsNonRoot: true
          readOnlyRootFilesystem: true
          capabilities:
            drop:
              - ALL
        args:
        - --service-name=k8s-httpcache
        - --namespace=$(NAMESPACE)
        - --vcl-template=/etc/k8s-httpcache/vcl.tmpl
        - --secret-path=/var/lib/varnish/secrets/secret
        - --broadcast-addr=:8088
        - --backend=backend:backend
        - --backend=backend-port:backend:8080
        - --backend=backend-named:backend:http
        - --backend=backend-xns:test-ns/backend-xns
        - --backend=backend-ext:backend-external:80
        - --values=test:k8s-httpcache-values-test
        - --values-dir=dirtest:/etc/values-dir-test
        - --drain
        - --drain-delay=15s
        - --drain-timeout=30s
        - --
        - -s
        - default,1M
        - -t
        - 5s
        - -p
        - default_grace=0s
        - -p
        - default_keep=0s
        - -p
        - timeout_idle=75s
        - -p
        - backend_idle_timeout=5s
        env:
        - name: NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        ports:
        - name: http
          containerPort: 8080
          protocol: TCP
        - name: http-b
          containerPort: 8088
          protocol: TCP
        startupProbe:
          httpGet:
            path: /ready
            port: http
          failureThreshold: 30
          periodSeconds: 1
        volumeMounts:
        - name: vcl-template
          mountPath: /etc/k8s-httpcache
          readOnly: true
        - name: values-dir-test
          mountPath: /etc/values-dir-test
          readOnly: true
        - name: tmp
          mountPath: /tmp
          readOnly: false
        - name: varlibvarnish
          mountPath: /var/lib/varnish
          readOnly: false
        resources:
          requests:
            cpu: 10m
            memory: 1Gi
          limits:
            cpu: "1"
            memory: 1Gi
      volumes:
      - name: tmp
        emptyDir:
          sizeLimit: 256Mi
          medium: Memory
      - name: varlibvarnish
        emptyDir:
          sizeLimit: 512Mi
          medium: Memory
      - name: vcl-template
        configMap:
          name: k8s-httpcache-vcl
      - name: values-dir-test
        configMap:
          name: k8s-httpcache-values-dir-test
---
apiVersion: v1
kind: Service
metadata:
  name: k8s-httpcache
  namespace: default
spec:
  selector:
    app: k8s-httpcache
  ports:
  - name: http
    protocol: TCP
    port: 80
    targetPort: http
  - name: http-b
    protocol: TCP
    port: 8088
    targetPort: http-b
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: k8s-httpcache
  namespace: default
spec:
  rules:
  - http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: k8s-httpcache
            port:
              number: 80
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: k8s-httpcache-vcl
  namespace: default
data:
  vcl.tmpl: |
    vcl 4.1;

    import directors;
    import std;

    <<- range .Frontends >>
    backend << .Name >> {
      .host = "<< .IP >>";
      .port = "<< .Port >>";
    }
    <<- end >>

    <<- range $name, $eps := .Backends >>
    <<- range $eps >>
    backend << .Name >>_<< $name >> {
      .host = "<< .IP >>";
      .port = "<< .Port >>";
    }
    <<- end >>
    <<- end >>

    acl purge {
      "127.0.0.0/8";
    }

    sub vcl_init {
      <<- if .Frontends >>
      new cluster = directors.shard();
      <<- range .Frontends >>
      cluster.add_backend(<< .Name >>);
      <<- end >>
      cluster.reconfigure();
      <<- end >>

      <<- range $name, $eps := .Backends >>
      new backend_<< $name >> = directors.round_robin();
      <<- range $eps >>
      backend_<< $name >>.add_backend(<< .Name >>_<< $name >>);
      <<- end >>
      <<- end >>
    }

    sub handle_readiness {
      if (req.url == "/ready") {
        return (synth(200));
      }
    }

    sub vcl_recv {
      call handle_readiness;

      if (req.method == "PURGE") {
        if (!client.ip ~ purge) {
          return (synth(405, "Not allowed"));
        }
        return (purge);
      }

      <<- if .Frontends >>
      if (!req.http.X-Shard-Routed) {
        set req.backend_hint = cluster.backend(by=URL);
        set req.http.x-shard = req.backend_hint;
        if (req.http.x-shard != server.identity) {
          set req.http.X-Shard-Routed = "true";
          return(pass);
        }
      }
      <<- end >>

      <<- range $name, $_ := .Backends >>
      if (req.url ~ "^/<< $name >>/") {
        set req.backend_hint = backend_<< $name >>.backend();
      }
      <<- end >>
    }

    sub vcl_purge {
      return (synth(200, "Purged"));
    }

    sub vcl_deliver {
      set resp.http.X-Values-Test = "<< index .Values.test "greeting" >>";
      set resp.http.X-Values-Nested = "<< .Values.test.server.host >>";
      set resp.http.X-ValuesDir-Test = "<< index .Values.dirtest "greeting" >>";
      set resp.http.X-ValuesDir-Nested = "<< .Values.dirtest.server.host >>";
    }
