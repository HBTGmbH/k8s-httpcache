apiVersion: v1
kind: ServiceAccount
metadata:
  name: k8s-httpcache
  namespace: default
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: k8s-httpcache
  namespace: default
rules:
- apiGroups: [""]
  resources: ["services"]
  verbs: ["list", "watch"]
- apiGroups: ["discovery.k8s.io"]
  resources: ["endpointslices"]
  verbs: ["list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: k8s-httpcache
  namespace: default
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: k8s-httpcache
subjects:
- kind: ServiceAccount
  name: k8s-httpcache
  namespace: default
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: k8s-httpcache
  namespace: default
spec:
  replicas: 3
  selector:
    matchLabels:
      app: k8s-httpcache
  template:
    metadata:
      labels:
        app: k8s-httpcache
    spec:
      serviceAccountName: k8s-httpcache
      terminationGracePeriodSeconds: 90
      containers:
      - name: k8s-httpcache
        image: ${IMAGE_REPO_PREFIX}/k8s-httpcache:1.0.0
        imagePullPolicy: Always
        securityContext:
          allowPrivilegeEscalation: false
          privileged: false
          runAsUser: 1000  # <-- varnish user uses uid=1000 also in the container image
          runAsGroup: 1000  # <-- varnish user uses gid=1000 also in the container image
          runAsNonRoot: true
          readOnlyRootFilesystem: true
          capabilities:
            drop:
            - ALL
        args:
        - --service-name=k8s-httpcache
        - --namespace=$(NAMESPACE)
        - --vcl-template=/etc/k8s-httpcache/vcl.tmpl
        - --secret-path=/var/lib/varnish/secrets/secret
        - --broadcast-addr=:8088
        - --backend=nginx:nginx
        - --backend=go-demo:go-demo
        - --drain
        - --drain-delay=15s
        - --
        - -s
        - default,1M
        - -t
        - 5s
        - -p
        - default_grace=0s
        - -p
        - default_keep=0s
        - -p
        - timeout_idle=75s
        - -p
        - backend_idle_timeout=5s
        env:
        - name: NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        ports:
        - name: http
          containerPort: 8080
          protocol: TCP
        - name: http-b
          containerPort: 8088
          protocol: TCP
        startupProbe:
          httpGet:
            path: /ready
            port: http
          failureThreshold: 30
          periodSeconds: 1
        volumeMounts:
        - name: vcl-template
          mountPath: /etc/k8s-httpcache
          readOnly: true
        - name: tmp
          mountPath: /tmp
          readOnly: false
        - name: varlibvarnish
          mountPath: /var/lib/varnish
          readOnly: false
        resources:
          requests:
            cpu: 10m
            memory: 1Gi
          limits:
            cpu: "1"
            memory: 1Gi
      volumes:
      - name: tmp
        emptyDir:
          sizeLimit: 256Mi
          medium: Memory
      - name: varlibvarnish
        emptyDir:
          sizeLimit: 512Mi
          medium: Memory
      - name: vcl-template
        configMap:
          name: k8s-httpcache-vcl
---
apiVersion: v1
kind: Service
metadata:
  name: k8s-httpcache
  namespace: default
spec:
  selector:
    app: k8s-httpcache
  ports:
  - name: http
    protocol: TCP
    port: 80
    targetPort: http
  - name: http-b
    protocol: TCP
    port: 8088
    targetPort: http-b
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: k8s-httpcache-vcl
  namespace: default
data:
  vcl.tmpl: |
    vcl 4.1;

    import directors;
    import std;

    <<- range .Frontends >>
    backend << .Name >> {
      .host = "<< .IP >>";
      .port = "<< .Port >>";
    }
    <<- end >>

    <<- range $name, $eps := .Backends >>
    <<- range $eps >>
    backend << .Name >>_<< $name >> {
      .host = "<< .IP >>";
      .port = "<< .Port >>";
    }
    <<- end >>
    <<- end >>

    acl purge {
      "localhost";
      "127.0.0.1";
      "::1";
    }

    sub vcl_init {
      <<- if .Frontends >>
      new cluster = directors.shard();
      <<- range .Frontends >>
      cluster.add_backend(<< .Name >>);
      <<- end >>
      cluster.reconfigure();
      <<- end >>

      <<- range $name, $eps := .Backends >>
      new backend_<< $name >> = directors.round_robin();
      <<- range $eps >>
      backend_<< $name >>.add_backend(<< .Name >>_<< $name >>);
      <<- end >>
      <<- end >>
    }

    sub vcl_recv {
      if (req.method == "PURGE") {
        if (!client.ip ~ purge) {
          return (synth(405, "Not allowed"));
        }
        return (purge);
      }

      <<- if .Frontends >>
      if (!req.http.X-Shard-Routed) {
        set req.backend_hint = cluster.backend(by=URL);
        set req.http.x-shard = req.backend_hint;
        if (req.http.x-shard != server.identity) {
          set req.http.X-Shard-Routed = "true";
          return(pass);
        }
      }
      <<- end >>

      <<- range $name, $_ := .Backends >>
      if (req.url ~ "^/<< $name >>/") {
        set req.backend_hint = backend_<< $name >>.backend();
        set req.url = regsub(req.url, "^/<< $name >>/", "/");
      }
      <<- end >>
    }

    sub vcl_purge {
      return (synth(200, "Purged"));
    }
